/**
 * @param {number[][]} points
 * @param {number} k
 * @return {number[][]}
 */
// var kClosest = function(points, k) {
//     // let minHeap = new MinPriorityQueue()
//     let pointsObj = {}
//     for(let point of points){
//         let sqRt = Math.sqrt((point[0]*point[0]) + (point[1]*point[1]))
//         pointsObj[point] = sqRt    
//     }
//     let sortable = []
//     for(let point in pointsObj){
//         sortable.push([[(point)], pointsObj[point]])
//     }
//     sortable.sort(function(a,b) { return a[1] - b[1]})
//     let resArr = []
//     for(let i=0; i<k; i++){
//         resArr.push(sortable[i][0])
//     }
//     return resArr;
// };
var kClosest = function(points, k) { 
    function dist(point){
        return Math.sqrt((point[0]**2) + (point[1]**2))
    }
    let minHeap = new MinPriorityQueue();
    for(let i=0; i<points.length; i++){
        minHeap.enqueue(points[i], dist(points[i]))
    }
    let res = [];
    for(let i=0; i<k; i++){
        res[i] = minHeap.dequeue().element;
    }
    return res
};
// let res = kClosest([[1,3],[-2,2]], 1)
let res = kClosest([[3,3],[5,-1],[-2,4]], 2)
console.log(res)